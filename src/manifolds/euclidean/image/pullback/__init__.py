import torch
from src.manifolds.euclidean.image import ImageEuclidean

class PullbackImageEuclidean(ImageEuclidean):
    """ Base class describing a R^d under a pullback Riemannian geometry generated by a Diffeomorphism """

    def __init__(self, image_manifold, image_diffeomorphism):
        super().__init__(image_diffeomorphism.C, image_diffeomorphism.H, image_diffeomorphism.W)
        self.phi = image_diffeomorphism 
        self.manifold = image_manifold

    def barycentre(self, x):
        """

        :param x: N x (C x H x W) 
        :return: (C x H x W) 
        """
        return self.phi.inverse(self.manifold.barycentre(self.phi.forward(x))[None])[0]

    def inner(self, x, X, Y):
        """

        :param x: N x (C x H x W) 
        :param X: N x M x (C x H x W) 
        :param Y: N x L x (C x H x W) 
        :return: N x M x L
        """
        M = X.shape[1]
        L = Y.shape[1]
        return self.manifold.inner(self.phi.forward(x),
                                   self.phi.differential_forward((x[:, None].repeat(1,M,1,1,1)).reshape(-1, self.C, self.H, self.W), X.reshape(-1, self.C, self.H, self.W)).reshape(X.shape),
                                   self.phi.differential_forward((x[:, None].repeat(1,L,1,1,1)).reshape(-1, self.C, self.H, self.W), Y.reshape(-1, self.C, self.H, self.W)).reshape(Y.shape)
                                   )

    def geodesic(self, x, y, t):
        """

        :param x: d or N x (C x H x W) 
        :param y: d or N x (C x H x W) 
        :param t: N or 1
        :return: N x (C x H x W) 
        """
        if len(t) == 1:
            return self.phi.inverse(self.manifold.geodesic(self.phi.forward(x), self.phi.forward(y), t))
        else:
            return self.phi.inverse(self.manifold.geodesic(self.phi.forward(x[None])[0], self.phi.forward(y[None])[0], t))
            

    def log(self, x, y):
        """

        :param x: (C x H x W) 
        :param y: N x (C x H x W) 
        :return: N x (C x H x W) 
        """
        N = y.shape[0]
        return self.phi.differential_inverse(self.phi.forward(x[None]).repeat(N,1,1,1),
                                                self.manifold.log(self.phi.forward(x[None])[0], self.phi.forward(y))
                                                )

    def exp(self, x, X):
        """

        :param x: (C x H x W) 
        :param X: N x (C x H x W) 
        :return: N x (C x H x W) 
        """
        N = X.shape[0]
        return self.phi.inverse(self.manifold.exp(self.phi.forward(x[None])[0], self.phi.differential_forward(x[None].repeat(N,1,1,1), X)))

    def distance(self, x, y):
        """

        :param x: N x M x (C x H x W) 
        :param y: N x L x (C x H x W) 
        :return: N x M x L
        """
        return self.manifold.distance(self.phi.forward(x.reshape(-1, self.C, self.H, self.W)).reshape(x.shape), self.phi.forward(y.reshape(-1, self.C, self.H, self.W)).reshape(y.shape))

    def parallel_transport(self, x, X, y):
        """

        :param x: (C x H x W) 
        :param X: N x (C x H x W) 
        :param y: (C x H x W) 
        :return: N x (C x H x W) 
        """
        N = X.shape[0]
        return self.phi.differential_inverse(self.phi.forward(y[None]).repeat(N,1,1,1),
                                                self.manifold.parallel_transport(self.phi.forward(x[None])[0],
                                                                                 self.phi.differential_forward(x[None].repeat(1,N,1,1,1), X),
                                                                                 self.phi.forward(y[None])[0]
                                                                                 )
                                                )
    